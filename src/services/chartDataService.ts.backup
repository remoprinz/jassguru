import { db } from '@/services/firebaseInit';
import { doc, getDoc, collection, getDocs } from 'firebase/firestore';

/**
 * ðŸŽ¯ CHART DATA SERVICE - NEUE STRUKTUR
 * =====================================
 * 
 * Liest direkt aus der neuen unified Datenstruktur:
 * - players/{playerId}/scoresHistory
 * - players/{playerId}/globalStats/current
 */

// âœ… Chart-Typen
export type ChartType = 'rating' | 'striche' | 'points';

/**
 * ðŸš€ NEUE STRUKTUR: Direkt aus players/{playerId}/scoresHistory lesen
 */
export async function getOptimizedChartData(
  groupId: string,
  chartType: ChartType,
  options?: {
    minDataPoints?: number;
    customColors?: boolean;
    sortByRating?: boolean;
  }
): Promise<{
  labels: string[];
  datasets: any[];
  source: 'backfill' | 'live';
  lastUpdated?: Date;
}> {
  try {
    // ðŸ“Š NEUE STRUKTUR: Lade alle Spieler der Gruppe
    const groupDoc = await getDoc(doc(db, 'groups', groupId));
    if (!groupDoc.exists()) {
      throw new Error(`Gruppe ${groupId} nicht gefunden`);
    }
    
    const groupData = groupDoc.data();
    const memberIds = groupData?.playerIds || groupData?.memberIds || [];
    
    if (memberIds.length === 0) {
      return {
        labels: [],
        datasets: [],
        source: 'live',
        lastUpdated: new Date()
      };
    }
    
    // âœ… FIX: FÃ¼r Rating-Charts: Lade aus ratingHistory, sonst aus scoresHistory
    const allPlayerData: { [playerId: string]: any[] } = {};
    const allLabels = new Set<string>();
    
    for (const playerId of memberIds) {
      try {
        // âœ… ENTSCHEIDE QUERY BASIEREND AUF CHARTTYPE
        const collectionName = chartType === 'rating' ? 'ratingHistory' : 'scoresHistory';
        
        const historySnapshot = await getDocs(
          collection(db, 'players', playerId, collectionName)
        );
        
        const playerHistory = historySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as any)).sort((a, b) => {
          // âœ… FIX: Verwende createdAt/completedAt/timestamp
          const tsA = a.createdAt || a.completedAt || a.timestamp;
          const tsB = b.createdAt || b.completedAt || b.timestamp;
          
          const dateA = tsA?.toDate ? tsA.toDate() : (tsA?._seconds ? new Date(tsA._seconds * 1000) : new Date(0));
          const dateB = tsB?.toDate ? tsB.toDate() : (tsB?._seconds ? new Date(tsB._seconds * 1000) : new Date(0));
          
          return dateA.getTime() - dateB.getTime();
        });
        
        allPlayerData[playerId] = playerHistory;
        
        // âœ… NEU: FÃ¼r Rating-Charts: Gruppiere nach Session, nicht nach Datum
        if (chartType === 'rating') {
          // Gruppiere nach sessionId, nehme jeweils den letzten Eintrag NACH GAMENUMBER
          const sessionMap = new Map<string, any>();
          playerHistory.forEach(entry => {
            // âœ… FIX: FÃ¼r Tournaments verwende tournamentId_passeNumber als eindeutigen Key
            let sessionId: string;
            if (entry.tournamentId && entry.passeNumber !== undefined) {
              sessionId = `${entry.tournamentId}_${entry.passeNumber}`;
            } else {
              sessionId = entry.sessionId || entry.tournamentId || 'unknown';
            }
            if (!sessionId || sessionId === 'unknown') return;
            
          // âœ… WICHTIG: Akzeptiere 'session_end', 'tournament_end' UND 'game' EintrÃ¤ge
          // (nach Elo-Backfill sind alle EintrÃ¤ge als 'game' getaggt)
          if (entry.eventType !== 'session_end' && entry.eventType !== 'tournament_end' && entry.eventType !== 'game' && entry.eventType !== 'game_end') {
            return; // Ãœberspringe unerkannte Event-Typen
          }
          
          const timestamp = entry.createdAt || entry.completedAt || entry.timestamp;
          if (!timestamp) return;
          
          // Berechne Timestamp
          let time = 0;
          if (timestamp.toDate && typeof timestamp.toDate === 'function') {
            time = timestamp.toDate().getTime();
          } else if (timestamp._seconds !== undefined) {
            time = timestamp._seconds * 1000;
          }
          
          // âœ… KRITISCH: Bei 'game' EintrÃ¤gen MUSS nach gameNumber/passeNumber gefiltert werden
          // (nicht nach timestamp, da verschiedene Spieler minimal unterschiedliche timestamps haben kÃ¶nnen)
          const gameNumber = entry.gameNumber || entry.passeNumber || 0;
          const existing = sessionMap.get(sessionId);
          
          // Vergleiche zuerst gameNumber, dann timestamp als Tiebreaker
          if (!existing || gameNumber > existing.gameNumber || (gameNumber === existing.gameNumber && time > existing.time)) {
            sessionMap.set(sessionId, { entry, time, timestamp, gameNumber });
          }
          });
          
          // Sammle Labels vom letzten Spiel jeder Session
          sessionMap.forEach(({ entry, timestamp }) => {
            let date: Date;
            if (timestamp.toDate && typeof timestamp.toDate === 'function') {
              date = timestamp.toDate();
            } else if (timestamp._seconds !== undefined) {
              date = new Date(timestamp._seconds * 1000);
            } else {
              return;
            }
            
            allLabels.add(date.toLocaleDateString('de-DE'));
          });
        } else {
          // âœ… FÃœR ANDERE CHARTS: Nach Datum sammeln (wie vorher)
          playerHistory.forEach(entry => {
            const timestamp = entry.createdAt || entry.completedAt || entry.timestamp;
            if (!timestamp) return;
            
            let date: Date;
            if (timestamp.toDate && typeof timestamp.toDate === 'function') {
              date = timestamp.toDate();
            } else if (timestamp._seconds !== undefined) {
              date = new Date(timestamp._seconds * 1000);
            } else {
              return;
            }
            
            allLabels.add(date.toLocaleDateString('de-DE'));
          });
        }
        
      } catch (error) {
        console.warn(`Fehler beim Laden der Historie fÃ¼r Spieler ${playerId}:`, error);
      }
    }
    
    // Sortiere Labels chronologisch
    const sortedLabels = Array.from(allLabels).sort((a, b) => {
      const dateA = new Date(a.split('.').reverse().join('-'));
      const dateB = new Date(b.split('.').reverse().join('-'));
      return dateA.getTime() - dateB.getTime();
    });
    
    // Erstelle Datasets fÃ¼r jeden Spieler
    const datasets: any[] = [];
    
    for (const playerId of memberIds) {
      const playerHistory = allPlayerData[playerId] || [];
      
      // âœ… FILTER 1: Spieler mit zu wenigen Sessions ausschlieÃŸen
      if (playerHistory.length < (options?.minDataPoints || 2)) {
        continue;
      }
      
      // Erstelle Datenpunkte fÃ¼r jeden Label
      const data: (number | null)[] = [];
      
      // âœ… NEU: FÃ¼r Rating-Charts: Gruppiere nach Session
      let sessionMap: Map<string, any>;
      if (chartType === 'rating') {
        sessionMap = new Map<string, any>();
        playerHistory.forEach(entry => {
          // âœ… FIX: FÃ¼r Tournaments verwende tournamentId_passeNumber als eindeutigen Key
          let sessionId: string;
          if (entry.tournamentId && entry.passeNumber !== undefined) {
            sessionId = `${entry.tournamentId}_${entry.passeNumber}`;
          } else {
            sessionId = entry.sessionId || entry.tournamentId || 'unknown';
          }
          if (!sessionId || sessionId === 'unknown') return;
          
          // âœ… WICHTIG: Akzeptiere 'session_end', 'tournament_end' UND 'game' EintrÃ¤ge
          // (nach Elo-Backfill sind alle EintrÃ¤ge als 'game' getaggt)
          if (entry.eventType !== 'session_end' && entry.eventType !== 'tournament_end' && entry.eventType !== 'game' && entry.eventType !== 'game_end') {
            return; // Ãœberspringe unerkannte Event-Typen
          }
          
          const timestamp = entry.createdAt || entry.completedAt || entry.timestamp;
          if (!timestamp) return;
          
          let time = 0;
          if (timestamp.toDate && typeof timestamp.toDate === 'function') {
            time = timestamp.toDate().getTime();
          } else if (timestamp._seconds !== undefined) {
            time = timestamp._seconds * 1000;
          }
          
          // âœ… KRITISCH: Bei 'game' EintrÃ¤gen MUSS nach gameNumber/passeNumber gefiltert werden
          const gameNumber = entry.gameNumber || entry.passeNumber || 0;
          const existing = sessionMap.get(sessionId);
          
          // Vergleiche zuerst gameNumber, dann timestamp als Tiebreaker
          if (!existing || gameNumber > existing.gameNumber || (gameNumber === existing.gameNumber && time > existing.time)) {
            sessionMap.set(sessionId, { entry, time, timestamp, gameNumber });
          }
        });
      }
      
      sortedLabels.forEach(label => {
        if (chartType === 'rating') {
          // âœ… FÃ¼r Rating: Finde Session, die an diesem Datum endete
          let found = false;
          sessionMap!.forEach(({ entry, timestamp }) => {
            if (found) return;
            
            let date: Date;
            if (timestamp.toDate && typeof timestamp.toDate === 'function') {
              date = timestamp.toDate();
            } else if (timestamp._seconds !== undefined) {
              date = new Date(timestamp._seconds * 1000);
            } else {
              return;
            }
            
            if (date.toLocaleDateString('de-DE') === label) {
              data.push(entry.rating || 0);
              found = true;
            }
          });
          
          if (!found) {
            data.push(null);
          }
        } else {
          // âœ… FIX: Finde ALLE EintrÃ¤ge fÃ¼r dieses Datum, dann nehme den LETZTEN
          const entriesForDate = playerHistory.filter(e => {
            // âœ… FIX: Verwende createdAt oder completedAt statt timestamp
            const timestamp = e.createdAt || e.completedAt || e.timestamp;
            if (!timestamp) return false;
            
            let date: Date;
            if (timestamp.toDate && typeof timestamp.toDate === 'function') {
              date = timestamp.toDate();
            } else if (timestamp._seconds !== undefined) {
              date = new Date(timestamp._seconds * 1000);
            } else {
              return false;
            }
            
            return date.toLocaleDateString('de-DE') === label;
          });
          
          if (entriesForDate.length > 0) {
            // âœ… NEHME DEN LETZTEN EINTRAG (neuestes Rating des Tages)
            const entry = entriesForDate[entriesForDate.length - 1];
            
            // âœ… Spieler hat an diesem Datum gespielt - verwende den Wert
            let value = 0;
            if (chartType === 'striche') {
              value = entry.globalStatsSnapshot?.stricheDifference || 0;
            } else if (chartType === 'points') {
              value = entry.globalStatsSnapshot?.pointsDifference || 0;
            }
            data.push(value);
          } else {
            // âœ… Spieler hat an diesem Datum NICHT gespielt - null verwenden
            data.push(null);
          }
        }
      });
      
      // âœ… FILTER 2: PrÃ¼fe ob Spieler genug gÃ¼ltige Datenpunkte hat
      const validPoints = data.filter(point => point !== null && point !== undefined && !isNaN(point));
      if (validPoints.length < (options?.minDataPoints || 2)) {
        continue;
      }
      
      // Hole Spieler-Name
      const playerDoc = await getDoc(doc(db, 'players', playerId));
      const playerName = playerDoc.exists() ? playerDoc.data()?.displayName || 'Unbekannt' : 'Unbekannt';
      
      datasets.push({
        label: playerName,
        data: data,
        playerId: playerId, // âœ… NEU: Player ID fÃ¼r chartRankingUtils
        borderColor: '#000000', // TemporÃ¤r - wird nach Sortierung Ã¼berschrieben
        backgroundColor: '#000000', // TemporÃ¤r - wird nach Sortierung Ã¼berschrieben
        borderWidth: 2,
        fill: false,
        tension: 0.4
      });
    }
    
    // âœ… SORTIERE DATASETS NACH AKTUELLEM RANKING (letzter gÃ¼ltiger Wert)
    datasets.sort((a, b) => {
      // Finde den letzten gÃ¼ltigen Wert fÃ¼r jeden Spieler
      const getLastValidValue = (dataset: any) => {
        for (let i = dataset.data.length - 1; i >= 0; i--) {
          const value = dataset.data[i];
          if (value !== null && value !== undefined && !isNaN(value)) {
            return value;
          }
        }
        return 0;
      };
      
      const aValue = getLastValidValue(a);
      const bValue = getLastValidValue(b);
      
      // Sortiere absteigend (hÃ¶chste Werte zuerst)
      return bValue - aValue;
    });
    
    // âœ… WEISE RANKING-BASIERTE FARBEN ZU
    datasets.forEach((dataset, index) => {
      const rank = index + 1; // Rang 1, 2, 3, ...
      dataset.borderColor = getRankingColor(rank);
      dataset.backgroundColor = getRankingColor(rank, 0.1);
    });
    
    return {
      labels: sortedLabels,
      datasets: datasets,
      source: 'live',
      lastUpdated: new Date()
    };
    
  } catch (error) {
    console.error('[getOptimizedChartData] Fehler:', error);
    return {
      labels: [],
      datasets: [],
      source: 'live',
      lastUpdated: new Date()
    };
  }
}

// ðŸŽ¨ BEST PRACTICE FARBPALETTE - FARBTHEORIE-BASIERT
function getRankingColor(rank: number, alpha: number = 1): string {
  // âœ… FARBTHEORIE-BASIERTE REIHENFOLGE (Ã¤sthetisch harmonisch)
  const baseColors = [
    '#10b981', // 1. GrÃ¼n (Emerald) - Erfolg/Spitze
    '#3b82f6', // 2. Blau (Blue) - Vertrauen/StabilitÃ¤t  
    '#a855f7', // 3. Lila (Purple) - KreativitÃ¤t/Exzellenz
    '#f97316', // 4. Orange (Orange) - Energie/Dynamik
    '#06b6d4', // 5. Cyan (Cyan) - Frische/ModernitÃ¤t
    '#ec4899', // 6. Pink (Pink) - Lebendigkeit/Charme
    '#eab308', // 7. Gelb (Yellow) - Optimismus/Freude
    '#14b8a6', // 8. Teal (Teal) - Balance/Harmonie
    '#ef4444', // 9. Rot (Red) - Warnung/Aufmerksamkeit
    '#6366f1'  // 10. Indigo (Indigo) - Tiefe/SeriositÃ¤t
  ];
  
  const baseIndex = (rank - 1) % baseColors.length; // 0-9
  const round = Math.floor((rank - 1) / baseColors.length); // 0, 1, 2, ...
  
  let color = baseColors[baseIndex];
  
  // âœ… HELLIGKEITSVARIATIONEN FÃœR 20+ SPIELER
  if (round === 1) {
    // Runde 2 (Rang 11-20): 20% dunkler
    color = darkenColor(color, 20);
  } else if (round === 2) {
    // Runde 3 (Rang 21-30): 20% heller
    color = lightenColor(color, 20);
  } else if (round === 3) {
    // Runde 4 (Rang 31-40): 40% dunkler
    color = darkenColor(color, 40);
  } else if (round >= 4) {
    // Runde 5+ (Rang 41+): 60% dunkler
    color = darkenColor(color, 60);
  }
  
  if (alpha < 1) {
    return color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
  }
  
  return color;
}

// âœ… HILFSFUNKTIONEN FÃœR FARBANPASSUNG
function darkenColor(color: string, percent: number): string {
  const hex = color.replace('#', '');
  const r = parseInt(hex.substr(0, 2), 16);
  const g = parseInt(hex.substr(2, 2), 16);
  const b = parseInt(hex.substr(4, 2), 16);
  
  const newR = Math.max(0, Math.floor(r * (1 - percent / 100)));
  const newG = Math.max(0, Math.floor(g * (1 - percent / 100)));
  const newB = Math.max(0, Math.floor(b * (1 - percent / 100)));
  
  return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
}

function lightenColor(color: string, percent: number): string {
  const hex = color.replace('#', '');
  const r = parseInt(hex.substr(0, 2), 16);
  const g = parseInt(hex.substr(2, 2), 16);
  const b = parseInt(hex.substr(4, 2), 16);
  
  const newR = Math.min(255, Math.floor(r + (255 - r) * percent / 100));
  const newG = Math.min(255, Math.floor(g + (255 - g) * percent / 100));
  const newB = Math.min(255, Math.floor(b + (255 - b) * percent / 100));
  
  return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
}

// Wrapper-Funktionen fÃ¼r verschiedene Chart-Typen
export async function getOptimizedRatingChart(groupId: string, options?: {
  minDataPoints?: number;
  customColors?: boolean;
  sortByRating?: boolean;
}) {
  return getOptimizedChartData(groupId, 'rating', {
    minDataPoints: options?.minDataPoints || 2,
    customColors: options?.customColors || true,
    sortByRating: options?.sortByRating || true,
  });
}

export async function getOptimizedStricheChart(groupId: string, options?: {
  minDataPoints?: number;
  customColors?: boolean;
  sortByRating?: boolean;
}) {
  return getOptimizedChartData(groupId, 'striche', {
    minDataPoints: options?.minDataPoints || 2,
    customColors: options?.customColors || true,
    sortByRating: options?.sortByRating || true,
  });
}

export async function getOptimizedPointsChart(groupId: string, options?: {
  minDataPoints?: number;
  customColors?: boolean;
  sortByRating?: boolean;
}) {
  return getOptimizedChartData(groupId, 'points', {
    minDataPoints: options?.minDataPoints || 2,
    customColors: options?.customColors || true,
    sortByRating: options?.sortByRating || true,
  });
}

// Backfill-Status (fÃ¼r KompatibilitÃ¤t)
export async function getBackfillStatus(groupId: string): Promise<{
  isBackfilled: boolean;
  lastUpdated?: Date;
}> {
    return {
    isBackfilled: true, // Neue Struktur ist immer "backfilled"
    lastUpdated: new Date()
  };
}